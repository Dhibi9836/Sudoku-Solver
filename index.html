<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sudoku Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the Sudoku grid cells */
        .sudoku-cell {
            /* Use viewport width units to make cells responsive */
            width: 9.5vw;
            height: 9.5vw;
            /* Set a max size for larger screens */
            max-width: 50px;
            max-height: 50px;
            /* Make font size responsive too */
            font-size: 4.5vw;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        @media (min-width: 540px) {
            .sudoku-cell {
                font-size: 24px; /* Fix font size on larger screens */
            }
        }
        
        /* Add thicker borders to separate the 3x3 boxes */
        .sudoku-row .sudoku-cell:nth-child(3),
        .sudoku-row .sudoku-cell:nth-child(6) {
            border-right-width: 4px;
        }
        .sudoku-row:nth-child(3) .sudoku-cell,
        .sudoku-row:nth-child(6) .sudoku-cell {
            border-bottom-width: 4px;
        }

        /* Dark theme cell styles */
        .dark .sudoku-cell.initial-value { background-color: #334155; color: #e2e8f0; }
        .dark .sudoku-cell.solved-value { color: #60a5fa; }
        
        /* Custom message box styles */
        #message-box {
            transition: opacity 0.5s, transform 0.5s;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-slate-800 p-4 sm:p-8 rounded-2xl shadow-2xl w-full max-w-md mx-auto relative">

        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-100">Sudoku Solver</h1>
            <p class="text-slate-400 mt-2">Enter a valid Sudoku</p>
        </div>

        <!-- Sudoku Grid -->
        <div id="sudoku-board" class="border-2 border-slate-500 rounded-lg overflow-hidden mx-auto">
            <!-- Cells will be generated by JavaScript -->
        </div>

        <!-- Action Buttons -->
        <div class="flex justify-center space-x-4 mt-6">
            <button id="solve-button" class="bg-blue-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-transform transform hover:scale-105">
                Solve
            </button>
            <button id="clear-button" class="bg-slate-600 text-slate-100 font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-slate-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">
                Clear
            </button>
        </div>
    </div>
    
    <!-- Message Box -->
    <div id="message-box" class="fixed top-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transform -translate-y-10">
        <p id="message-text"></p>
    </div>

    <footer class="text-center text-slate-400 mt-8 text-sm">
        <p>Use arrow keys to navigate, and Space, Backspace, or Delete to clear a cell.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('sudoku-board');
            const solveButton = document.getElementById('solve-button');
            const clearButton = document.getElementById('clear-button');
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            
            // --- Board Generation ---
            function createBoard() {
                boardElement.innerHTML = ''; // Clear previous board
                for (let i = 0; i < 9; i++) {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'sudoku-row flex';
                    for (let j = 0; j < 9; j++) {
                        const cell = document.createElement('input');
                        cell.type = 'text';
                        // We handle maxLength in JS now, but this is a good fallback
                        cell.maxLength = 1;
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.className = 'sudoku-cell border border-slate-600 bg-slate-800 text-slate-200 text-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:bg-slate-700 transition-colors';
                        rowElement.appendChild(cell);
                    }
                    boardElement.appendChild(rowElement);
                }
            }

            createBoard();

            // --- Keyboard Navigation & Input ---
            boardElement.addEventListener('keydown', (e) => {
                if (e.target.tagName !== 'INPUT') return;

                const target = e.target;
                let row = parseInt(target.dataset.row);
                let col = parseInt(target.dataset.col);

                // If board is solved and read-only, only allow navigation
                if (target.readOnly) {
                    switch (e.key) {
                        case 'ArrowUp': e.preventDefault(); row = row > 0 ? row - 1 : 8; break;
                        case 'ArrowDown': e.preventDefault(); row = row < 8 ? row + 1 : 0; break;
                        case 'ArrowLeft': e.preventDefault(); col = col > 0 ? col - 1 : 8; break;
                        case 'ArrowRight': e.preventDefault(); col = col < 8 ? col + 1 : 0; break;
                        default: e.preventDefault(); return; // Prevent all other actions
                    }
                    const nextCell = boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (nextCell) nextCell.focus();
                    return;
                }

                // Handle digit input (1-9) to replace existing content
                if (/^[1-9]$/.test(e.key)) {
                    e.preventDefault();
                    target.value = e.key;
                    return;
                }
                
                // Handle navigation and clearing
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        row = row > 0 ? row - 1 : 8;
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        row = row < 8 ? row + 1 : 0;
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        col = col > 0 ? col - 1 : 8;
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        col = col < 8 ? col + 1 : 0;
                        break;
                    case ' ':
                    case 'Backspace':
                    case 'Delete':
                        e.preventDefault();
                        target.value = '';
                        return; // Exit after clearing
                    default:
                        // Prevent any other characters from being entered, but allow control keys
                        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                           e.preventDefault();
                        }
                        return; // Allow keys like Tab, etc.
                }

                const nextCellToFocus = boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (nextCellToFocus) {
                    nextCellToFocus.focus();
                }
            });

            // --- Message Display ---
            function showMessage(message, isError = true) {
                messageText.textContent = message;
                messageBox.className = `fixed top-5 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transform -translate-y-10 ${isError ? 'bg-red-500' : 'bg-green-500'}`;
                messageBox.classList.remove('opacity-0', '-translate-y-10');
                messageBox.classList.add('opacity-100', 'translate-y-0');
                setTimeout(() => {
                    messageBox.classList.remove('opacity-100', 'translate-y-0');
                    messageBox.classList.add('opacity-0', '-translate-y-10');
                }, 3000);
            }

            // --- Board Data Conversion ---
            function getBoardState() {
                const board = Array(9).fill(null).map(() => Array(9).fill('.'));
                const cells = boardElement.querySelectorAll('input');
                let isValid = true;
                const rows = Array(9).fill(null).map(() => new Set());
                const cols = Array(9).fill(null).map(() => new Set());
                const boxes = Array(9).fill(null).map(() => new Set());

                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const value = cell.value;
                    cell.classList.remove('border-red-500');

                    if (value >= '1' && value <= '9') {
                        const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                        if (rows[row].has(value) || cols[col].has(value) || boxes[boxIndex].has(value)) {
                            showMessage(`Invalid input: Duplicate '${value}' found.`);
                            cells.forEach(c => {
                                if (c.value === value) {
                                    const r = parseInt(c.dataset.row);
                                    const c_col = parseInt(c.dataset.col);
                                    const b_idx = Math.floor(r / 3) * 3 + Math.floor(c_col / 3);
                                    if (r === row || c_col === col || b_idx === boxIndex) {
                                        c.classList.add('border-red-500');
                                    }
                                }
                            });
                            isValid = false;
                        }
                        rows[row].add(value);
                        cols[col].add(value);
                        boxes[boxIndex].add(value);
                        board[row][col] = value;
                        cell.classList.add('initial-value');
                    } else {
                        cell.classList.remove('initial-value', 'solved-value');
                    }
                });
                return isValid ? board : null;
            }

            function updateBoardUI(board) {
                const cells = boardElement.querySelectorAll('input');
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const newValue = board[row][col];
                    if (!cell.classList.contains('initial-value')) {
                         cell.value = newValue;
                         cell.classList.add('solved-value');
                    }
                    cell.readOnly = true;
                });
            }

            // --- Sudoku Solver Logic with Solution Counting (Optimized) ---
            function countSolutions(board) {
                let solutionCount = 0;
                let firstSolution = null;

                function copyBoard(b) {
                    return b.map(row => [...row]);
                }

                function isValidPlacement(row, col, val) {
                    for (let i = 0; i < 9; i++) {
                        if (board[row][i] === val) return false; // Check row
                        if (board[i][col] === val) return false; // Check col
                    }
                    const boxRowStart = Math.floor(row / 3) * 3;
                    const boxColStart = Math.floor(col / 3) * 3;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            if (board[boxRowStart + i][boxColStart + j] === val) return false; // Check box
                        }
                    }
                    return true;
                }

                function find() {
                    // OPTIMIZATION: Stop searching if more than one solution is found.
                    if (solutionCount > 1) {
                        return;
                    }

                    let row = -1, col = -1;
                    for (let i = 0; i < 9; i++) {
                        for (let j = 0; j < 9; j++) {
                            if (board[i][j] === '.') {
                                row = i;
                                col = j;
                                break;
                            }
                        }
                        if (row !== -1) break;
                    }

                    if (row === -1) { // No empty cells left, a solution is found
                        solutionCount++;
                        if (solutionCount === 1) {
                            firstSolution = copyBoard(board);
                        }
                        return;
                    }
                    
                    for (let num = 1; num <= 9; num++) {
                        const val = String(num);
                        if (isValidPlacement(row, col, val)) {
                            board[row][col] = val;
                            find();
                            board[row][col] = '.'; // Backtrack
                        }
                    }
                }

                find();
                return { count: solutionCount, solution: firstSolution };
            }


            // --- Event Listeners ---
            solveButton.addEventListener('click', () => {
                const allCells = boardElement.querySelectorAll('input');
                allCells.forEach(cell => {
                    cell.classList.remove('border-red-500', 'solved-value');
                    cell.readOnly = false;
                });

                const board = getBoardState();
                if (board) {
                    let initialClues = 0;
                    board.forEach(row => row.forEach(cell => { if (cell !== '.') initialClues++; }));

                    if (initialClues < 17) {
                        showMessage("A valid Sudoku must have at least 17 clues");
                        return;
                    }

                    const result = countSolutions(board);

                    if (result.count === 1) {
                        updateBoardUI(result.solution);
                        showMessage("Here's the Solved Sudoku", false);
                    } else if (result.count > 1) {
                        showMessage("This Sudoku has multiple solutions.");
                    } else { // result.count === 0
                        showMessage("This Sudoku has no solution");
                    }
                }
            });

            clearButton.addEventListener('click', () => {
                const cells = boardElement.querySelectorAll('input');
                cells.forEach(cell => {
                    cell.value = '';
                    cell.readOnly = false;
                    cell.classList.remove('initial-value', 'solved-value', 'border-red-500');
                });
                showMessage("Cleared.", false);
            });
        });
    </script>
</body>
</html>

